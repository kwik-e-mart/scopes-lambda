#!/bin/bash

echo "üîç Validating Lambda compute configuration..."

# Extract values from CONTEXT
lambda_function_name=$(echo "$CONTEXT" | jq -r '.lambda.function_name // empty')
lambda_role_arn=$(echo "$CONTEXT" | jq -r '.lambda.role_arn // empty')

# Get asset information
asset_url=$(echo "$CONTEXT" | jq -r '.asset.url // empty')

if [ -z "$asset_url" ] || [ "$asset_url" = "null" ]; then
  echo ""
  echo "   ‚ùå Asset URL not found in context"
  echo ""
  echo "  üí° Possible causes:"
  echo "    ‚Ä¢ The deployment does not have an associated asset"
  echo "    ‚Ä¢ The asset was not built or uploaded correctly"
  echo ""
  echo "  üîß How to fix:"
  echo "    ‚Ä¢ Ensure the application has a valid build that produces a Lambda deployment package"
  echo ""
  return 1
fi

echo "   ‚úÖ asset_url=$asset_url"

# Parse S3 URL to extract bucket and key
# Supports both s3:// and https:// formats
if [[ "$asset_url" == s3://* ]]; then
  # s3://bucket-name/path/to/file.zip
  lambda_s3_bucket=$(echo "$asset_url" | sed 's|s3://||' | cut -d'/' -f1)
  lambda_s3_key=$(echo "$asset_url" | sed 's|s3://[^/]*/||')
elif [[ "$asset_url" == https://*.s3.*.amazonaws.com/* ]]; then
  # https://bucket-name.s3.region.amazonaws.com/path/to/file.zip
  lambda_s3_bucket=$(echo "$asset_url" | sed 's|https://||' | cut -d'.' -f1)
  lambda_s3_key=$(echo "$asset_url" | sed 's|https://[^/]*/||')
else
  echo ""
  echo "   ‚ùå Unsupported asset URL format: $asset_url"
  echo ""
  echo "  üîß How to fix:"
  echo "    ‚Ä¢ Asset URL must be in S3 format (s3://bucket/key or https://bucket.s3.region.amazonaws.com/key)"
  echo ""
  return 1
fi

echo "   ‚úÖ s3_bucket=$lambda_s3_bucket"
echo "   ‚úÖ s3_key=$lambda_s3_key"

# Extract capabilities from scope
runtime=$(echo "$CONTEXT" | jq -r '.scope.capabilities.runtime // "nodejs20.x"')
handler=$(echo "$CONTEXT" | jq -r '.scope.capabilities.handler // "index.handler"')
memory=$(echo "$CONTEXT" | jq -r '.scope.capabilities.memory // 256')
timeout=$(echo "$CONTEXT" | jq -r '.scope.capabilities.timeout // 30')
ephemeral_storage=$(echo "$CONTEXT" | jq -r '.scope.capabilities.ephemeral_storage // 512')
architecture=$(echo "$CONTEXT" | jq -r '.scope.capabilities.architecture // "arm64"')

echo "   ‚úÖ runtime=$runtime"
echo "   ‚úÖ handler=$handler"
echo "   ‚úÖ memory=${memory}MB"
echo "   ‚úÖ timeout=${timeout}s"
echo "   ‚úÖ architecture=$architecture"

# Reserved concurrency
reserved_type=$(echo "$CONTEXT" | jq -r '.scope.capabilities.reserved_concurrency.type // "unreserved"')
reserved_value=$(echo "$CONTEXT" | jq -r '.scope.capabilities.reserved_concurrency.value // 0')

# Provisioned concurrency
provisioned_type=$(echo "$CONTEXT" | jq -r '.scope.capabilities.provisioned_concurrency.type // "unprovisioned"')
provisioned_value=$(echo "$CONTEXT" | jq -r '.scope.capabilities.provisioned_concurrency.value // 0')
warmup_alias=$(echo "$CONTEXT" | jq -r '.scope.capabilities.provisioned_concurrency.warmup_alias // ""')

echo "   ‚úÖ reserved_concurrency=$reserved_type ($reserved_value)"
echo "   ‚úÖ provisioned_concurrency=$provisioned_type ($provisioned_value)"

if [ -n "$warmup_alias" ] && [ "$warmup_alias" != "null" ] && [ "$warmup_alias" != "" ]; then
  echo "   ‚úÖ warmup_alias=$warmup_alias"
fi

# VPC configuration
vpc_enabled=$(echo "$CONTEXT" | jq -r '.scope.capabilities.vpc_enabled // false')
vpc_config="null"

if [ "$vpc_enabled" = "true" ]; then
  subnet_ids=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].networking.subnet_ids // empty')
  security_group_ids=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].networking.security_group_ids // empty')

  if [ -n "$subnet_ids" ] && [ -n "$security_group_ids" ]; then
    vpc_config=$(jq -n \
      --argjson subnet_ids "$subnet_ids" \
      --argjson security_group_ids "$security_group_ids" \
      '{subnet_ids: $subnet_ids, security_group_ids: $security_group_ids}')
    echo "   ‚úÖ vpc_enabled=true"
  else
    echo ""
    echo "   ‚ùå VPC enabled but subnet_ids or security_group_ids not configured"
    echo ""
    echo "  üîß How to fix:"
    echo "    ‚Ä¢ Configure networking.subnet_ids and networking.security_group_ids in the cloud-provider"
    echo ""
    return 1
  fi
fi

# Lambda layers
custom_layers=$(echo "$CONTEXT" | jq -c '.scope.capabilities.layers // []')

# Add nullplatform agent layer if enabled
if [ "${USE_NULL_AGENT:-true}" = "true" ] && [ -n "${NULL_AGENT_LAYER_ARN:-}" ]; then
  custom_layers=$(echo "$custom_layers" | jq --arg layer "$NULL_AGENT_LAYER_ARN" '. + [$layer]')
  echo "   ‚úÖ nullplatform_agent_layer=$NULL_AGENT_LAYER_ARN"
fi

# Build environment variables from parameters
env_vars=$(echo "$CONTEXT" | jq -c '
  .parameters.results // [] |
  map(select(.resolved_value != null)) |
  map({(.name): .resolved_value}) |
  add // {}
')

# Add deployment metadata to environment
deployment_id=$(echo "$CONTEXT" | jq -r '.deployment.id')
env_vars=$(echo "$env_vars" | jq \
  --arg deployment_id "$deployment_id" \
  '. + {NP_DEPLOYMENT_ID: $deployment_id}')

# Add agent wrapper if using nullplatform layer
if [ "${USE_NULL_AGENT:-true}" = "true" ] && [ -n "${NULL_AGENT_LAYER_ARN:-}" ]; then
  env_vars=$(echo "$env_vars" | jq '. + {AWS_LAMBDA_EXEC_WRAPPER: "/opt/nullplatform/wrapper"}')
fi

echo ""
echo "   üì° Building Lambda configuration..."

# Main alias name
main_alias_name="${LAMBDA_MAIN_ALIAS_NAME:-main}"

# Validate function name
if [ -z "$lambda_function_name" ] || [ "$lambda_function_name" = "null" ]; then
  echo ""
  echo "   ‚ùå Lambda function name not found in context"
  echo ""
  echo "  üí° Possible causes:"
  echo "    ‚Ä¢ Scope was not created properly"
  echo "    ‚Ä¢ Lambda placeholder was not created during scope creation"
  echo ""
  return 1
fi

echo "   ‚úÖ function_name=$lambda_function_name"

# Build TOFU_VARIABLES
TOFU_VARIABLES=$(echo "$TOFU_VARIABLES" | jq \
  --arg function_name "$lambda_function_name" \
  --arg runtime "$runtime" \
  --arg handler "$handler" \
  --argjson memory "$memory" \
  --argjson timeout "$timeout" \
  --argjson ephemeral_storage "$ephemeral_storage" \
  --arg architecture "$architecture" \
  --arg role_arn "$lambda_role_arn" \
  --arg s3_bucket "$lambda_s3_bucket" \
  --arg s3_key "$lambda_s3_key" \
  --argjson environment_variables "$env_vars" \
  --argjson layers "$custom_layers" \
  --argjson vpc_config "$vpc_config" \
  --arg reserved_type "$reserved_type" \
  --argjson reserved_value "$reserved_value" \
  --arg provisioned_type "$provisioned_type" \
  --argjson provisioned_value "$provisioned_value" \
  --arg main_alias_name "$main_alias_name" \
  --arg warmup_alias_name "$warmup_alias" \
  '. + {
    lambda_function_name: $function_name,
    lambda_runtime: $runtime,
    lambda_handler: $handler,
    lambda_memory_size: $memory,
    lambda_timeout: $timeout,
    lambda_ephemeral_storage: $ephemeral_storage,
    lambda_architecture: $architecture,
    lambda_role_arn: $role_arn,
    lambda_s3_bucket: $s3_bucket,
    lambda_s3_key: $s3_key,
    lambda_environment_variables: $environment_variables,
    lambda_layers: $layers,
    lambda_vpc_config: $vpc_config,
    lambda_reserved_concurrency_type: $reserved_type,
    lambda_reserved_concurrency_value: $reserved_value,
    lambda_provisioned_concurrency_type: $provisioned_type,
    lambda_provisioned_concurrency_value: $provisioned_value,
    lambda_main_alias_name: $main_alias_name,
    lambda_warmup_alias_name: $warmup_alias_name
  }')

echo ""
echo "‚ú® Lambda compute configured successfully"
echo ""

# Add module to composition list
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
module_name="${script_dir}/modules"

if [[ -n $MODULES_TO_USE ]]; then
  MODULES_TO_USE="$MODULES_TO_USE,$module_name"
else
  MODULES_TO_USE="$module_name"
fi
