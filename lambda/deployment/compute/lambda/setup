#!/bin/bash

source "$SERVICE_PATH/utils/log"

log info "ðŸ” Validating Lambda compute configuration..."

# Extract values from CONTEXT
lambda_function_name=$(echo "$CONTEXT" | jq -r '.lambda.function_name // empty')
lambda_role_arn=$(echo "$CONTEXT" | jq -r '.lambda.role_arn // empty')

# Get asset information
asset_url=$(echo "$CONTEXT" | jq -r '.asset.url // empty')

if [ -z "$asset_url" ] || [ "$asset_url" = "null" ]; then
  echo ""
  echo "   âŒ Asset URL not found in context" >&2
  echo "" >&2
  echo "  ðŸ’¡ Possible causes:" >&2
  echo "    â€¢ The deployment does not have an associated asset" >&2
  echo "    â€¢ The asset was not built or uploaded correctly" >&2
  echo "" >&2
  echo "  ðŸ”§ How to fix:" >&2
  echo "    â€¢ Ensure the application has a valid build that produces a Lambda deployment package" >&2
  echo "" >&2
  return 1
fi

log debug "   âœ… asset_url=$asset_url"

# Parse S3 URL to extract bucket and key
# Supports both s3:// and https:// formats
if [[ "$asset_url" == s3://* ]]; then
  # s3://bucket-name/path/to/file.zip
  lambda_s3_bucket=$(echo "$asset_url" | sed 's|s3://||' | cut -d'/' -f1)
  lambda_s3_key=$(echo "$asset_url" | sed 's|s3://[^/]*/||')
elif [[ "$asset_url" == https://*.s3.*.amazonaws.com/* ]]; then
  # https://bucket-name.s3.region.amazonaws.com/path/to/file.zip
  lambda_s3_bucket=$(echo "$asset_url" | sed 's|https://||' | cut -d'.' -f1)
  lambda_s3_key=$(echo "$asset_url" | sed 's|https://[^/]*/||')
else
  echo ""
  echo "   âŒ Unsupported asset URL format: $asset_url" >&2
  echo "" >&2
  echo "  ðŸ”§ How to fix:" >&2
  echo "    â€¢ Asset URL must be in S3 format (s3://bucket/key or https://bucket.s3.region.amazonaws.com/key)" >&2
  echo "" >&2
  return 1
fi

log debug "   âœ… s3_bucket=$lambda_s3_bucket"
log debug "   âœ… s3_key=$lambda_s3_key"

# Extract capabilities from scope
runtime=$(echo "$CONTEXT" | jq -r '.scope.capabilities.runtime // "nodejs20.x"')
handler=$(echo "$CONTEXT" | jq -r '.scope.capabilities.handler // "index.handler"')
memory=$(echo "$CONTEXT" | jq -r '.scope.capabilities.memory // 256')
timeout=$(echo "$CONTEXT" | jq -r '.scope.capabilities.timeout // 30')
ephemeral_storage=$(echo "$CONTEXT" | jq -r '.scope.capabilities.ephemeral_storage // 512')
architecture=$(echo "$CONTEXT" | jq -r '.scope.capabilities.architecture // "arm64"')

log debug "   âœ… runtime=$runtime"
log debug "   âœ… handler=$handler"
log debug "   âœ… memory=${memory}MB"
log debug "   âœ… timeout=${timeout}s"
log debug "   âœ… architecture=$architecture"

# Reserved concurrency
reserved_type=$(echo "$CONTEXT" | jq -r '.scope.capabilities.reserved_concurrency.type // "unreserved"')
reserved_value=$(echo "$CONTEXT" | jq -r '.scope.capabilities.reserved_concurrency.value // 0')

# Provisioned concurrency
provisioned_type=$(echo "$CONTEXT" | jq -r '.scope.capabilities.provisioned_concurrency.type // "unprovisioned"')
provisioned_value=$(echo "$CONTEXT" | jq -r '.scope.capabilities.provisioned_concurrency.value // 0')
warmup_alias=$(echo "$CONTEXT" | jq -r '.scope.capabilities.provisioned_concurrency.warmup_alias // ""')

log debug "   âœ… reserved_concurrency=$reserved_type ($reserved_value)"
log debug "   âœ… provisioned_concurrency=$provisioned_type ($provisioned_value)"

if [ -n "$warmup_alias" ] && [ "$warmup_alias" != "null" ] && [ "$warmup_alias" != "" ]; then
  log debug "   âœ… warmup_alias=$warmup_alias"
fi

# VPC configuration
vpc_enabled=$(echo "$CONTEXT" | jq -r '.scope.capabilities.vpc_enabled // false')
vpc_config="null"

if [ "$vpc_enabled" = "true" ]; then
  subnet_ids=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].networking.subnet_ids // empty')
  security_group_ids=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].networking.security_group_ids // empty')

  if [ -n "$subnet_ids" ] && [ -n "$security_group_ids" ]; then
    vpc_config=$(jq -n \
      --argjson subnet_ids "$subnet_ids" \
      --argjson security_group_ids "$security_group_ids" \
      '{subnet_ids: $subnet_ids, security_group_ids: $security_group_ids}')
    log debug "   âœ… vpc_enabled=true"
  else
    echo ""
    echo "   âŒ VPC enabled but subnet_ids or security_group_ids not configured" >&2
    echo "" >&2
    echo "  ðŸ”§ How to fix:" >&2
    echo "    â€¢ Configure networking.subnet_ids and networking.security_group_ids in the cloud-provider" >&2
    echo "" >&2
    return 1
  fi
fi

# Lambda layers
custom_layers=$(echo "$CONTEXT" | jq -c '.scope.capabilities.layers // []')

# Add nullplatform agent layer if enabled
if [ "${USE_NULL_AGENT:-true}" = "true" ] && [ -n "${NULL_AGENT_LAYER_ARN:-}" ]; then
  custom_layers=$(echo "$custom_layers" | jq --arg layer "$NULL_AGENT_LAYER_ARN" '. + [$layer]')
  log debug "   âœ… nullplatform_agent_layer=$NULL_AGENT_LAYER_ARN"
fi

# Build environment variables from parameters
env_vars=$(echo "$CONTEXT" | jq -c '
  .parameters.results // [] |
  map(select(.resolved_value != null)) |
  map({(.name): .resolved_value}) |
  add // {}
')

# Add deployment metadata to environment
deployment_id=$(echo "$CONTEXT" | jq -r '.deployment.id')
env_vars=$(echo "$env_vars" | jq \
  --arg deployment_id "$deployment_id" \
  '. + {NP_DEPLOYMENT_ID: $deployment_id}')

# Add agent wrapper if using nullplatform layer
if [ "${USE_NULL_AGENT:-true}" = "true" ] && [ -n "${NULL_AGENT_LAYER_ARN:-}" ]; then
  env_vars=$(echo "$env_vars" | jq '. + {AWS_LAMBDA_EXEC_WRAPPER: "/opt/nullplatform/wrapper"}')
fi

echo ""
log info "   ðŸ“¡ Building Lambda configuration..."

# Main alias name
main_alias_name="${LAMBDA_MAIN_ALIAS_NAME:-main}"

# Validate function name
if [ -z "$lambda_function_name" ] || [ "$lambda_function_name" = "null" ]; then
  echo ""
  echo "   âŒ Lambda function name not found in context" >&2
  echo "" >&2
  echo "  ðŸ’¡ Possible causes:" >&2
  echo "    â€¢ Scope was not created properly" >&2
  echo "    â€¢ Lambda placeholder was not created during scope creation" >&2
  echo "" >&2
  return 1
fi

log debug "   âœ… function_name=$lambda_function_name"

# Build TOFU_VARIABLES
TOFU_VARIABLES=$(echo "$TOFU_VARIABLES" | jq \
  --arg function_name "$lambda_function_name" \
  --arg runtime "$runtime" \
  --arg handler "$handler" \
  --argjson memory "$memory" \
  --argjson timeout "$timeout" \
  --argjson ephemeral_storage "$ephemeral_storage" \
  --arg architecture "$architecture" \
  --arg s3_bucket "$lambda_s3_bucket" \
  --arg s3_key "$lambda_s3_key" \
  --argjson environment_variables "$env_vars" \
  --argjson layers "$custom_layers" \
  --argjson vpc_config "$vpc_config" \
  --arg reserved_type "$reserved_type" \
  --argjson reserved_value "$reserved_value" \
  --arg provisioned_type "$provisioned_type" \
  --argjson provisioned_value "$provisioned_value" \
  --arg main_alias_name "$main_alias_name" \
  --arg warmup_alias_name "$warmup_alias" \
  --arg lambda_description "$deployment_id" \
  '. + {
    lambda_function_name: $function_name,
    lambda_runtime: $runtime,
    lambda_handler: $handler,
    lambda_memory_size: $memory,
    lambda_timeout: $timeout,
    lambda_ephemeral_storage: $ephemeral_storage,
    lambda_architecture: $architecture,
    lambda_s3_bucket: $s3_bucket,
    lambda_s3_key: $s3_key,
    lambda_environment_variables: $environment_variables,
    lambda_layers: $layers,
    lambda_vpc_config: $vpc_config,
    lambda_reserved_concurrency_type: $reserved_type,
    lambda_reserved_concurrency_value: $reserved_value,
    lambda_provisioned_concurrency_type: $provisioned_type,
    lambda_provisioned_concurrency_value: $provisioned_value,
    lambda_main_alias_name: $main_alias_name,
    lambda_warmup_alias_name: $warmup_alias_name,
    lambda_description: $lambda_description
  }')

echo ""
log info "âœ¨ Lambda compute configured successfully"
echo ""

# Add module to composition list
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
module_name="${script_dir}/modules"

if [[ -n $MODULES_TO_USE ]]; then
  MODULES_TO_USE="$MODULES_TO_USE,$module_name"
else
  MODULES_TO_USE="$module_name"
fi
