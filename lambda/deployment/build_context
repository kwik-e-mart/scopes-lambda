#!/bin/bash

# Source utility functions
source "$SERVICE_PATH/utils/get_config_value"

echo "üîç Building deployment context..."

# Extract scope information from context
SCOPE_ID=$(echo "$CONTEXT" | jq -r '.scope.id')
DEPLOYMENT_ID=$(echo "$CONTEXT" | jq -r '.deployment.id')
SCOPE_NRN=$(echo "$CONTEXT" | jq -r '.scope.nrn')

if [ -z "$SCOPE_ID" ] || [ "$SCOPE_ID" = "null" ]; then
  echo "‚ùå Failed to extract scope ID from context" >&2
  echo "üí° Possible causes:" >&2
  echo "   - CONTEXT variable is empty or malformed" >&2
  echo "   - The scope object is missing from the context payload" >&2
  echo "üîß How to fix:" >&2
  echo "   - Verify the CONTEXT environment variable contains valid JSON with .scope.id" >&2
  return 1
fi

if [ -z "$DEPLOYMENT_ID" ] || [ "$DEPLOYMENT_ID" = "null" ]; then
  echo "‚ùå Failed to extract deployment ID from context" >&2
  echo "üí° Possible causes:" >&2
  echo "   - CONTEXT variable is missing the deployment object" >&2
  echo "üîß How to fix:" >&2
  echo "   - Verify the CONTEXT environment variable contains valid JSON with .deployment.id" >&2
  return 1
fi

echo "   ‚úÖ scope_id=$SCOPE_ID"
echo "   ‚úÖ deployment_id=$DEPLOYMENT_ID"

# Extract slugs for naming
NAMESPACE_SLUG=$(echo "$CONTEXT" | jq -r '.namespace.slug')
APPLICATION_SLUG=$(echo "$CONTEXT" | jq -r '.application.slug')
SCOPE_SLUG=$(echo "$CONTEXT" | jq -r '.scope.slug')
ACCOUNT_SLUG=$(echo "$CONTEXT" | jq -r '.account.slug')

echo "   ‚úÖ namespace=$NAMESPACE_SLUG"
echo "   ‚úÖ application=$APPLICATION_SLUG"
echo "   ‚úÖ scope=$SCOPE_SLUG"

# Generate Lambda function name (max 64 chars)
# Format: {namespace}-{application}-{scope}-{scope_id}
LAMBDA_FUNCTION_NAME="${NAMESPACE_SLUG}-${APPLICATION_SLUG}-${SCOPE_SLUG}-${SCOPE_ID}"
LAMBDA_FUNCTION_NAME="${LAMBDA_FUNCTION_NAME:0:64}"
echo "   ‚úÖ function_name=$LAMBDA_FUNCTION_NAME"

# Get deployment strategy
DEPLOYMENT_STRATEGY=$(echo "$CONTEXT" | jq -r '.deployment.strategy // "initial"')
DESIRED_TRAFFIC=$(echo "$CONTEXT" | jq -r '.deployment.strategy_data.desired_switched_traffic // 100')

echo ""
echo "üìã Scope: $SCOPE_ID | Deployment: $DEPLOYMENT_ID | Strategy: $DEPLOYMENT_STRATEGY"

# Read existing Lambda metadata from NRN (if exists)
echo ""
echo "   üì° Reading Lambda metadata from NRN..."

LAMBDA_FUNCTION_ARN=""
LAMBDA_ROLE_ARN=""
LAMBDA_CURRENT_VERSION=""
LAMBDA_MAIN_ALIAS_NAME="${LAMBDA_MAIN_ALIAS_NAME:-main}"

nrn_output=$(np nrn read --nrn "$SCOPE_NRN" --ids "aws.LAMBDA_FUNCTION_ARN,aws.LAMBDA_ROLE_ARN,aws.LAMBDA_FUNCTION_CURRENT_VERSION,aws.LAMBDA_FUNCTION_MAIN_ALIAS,aws.LAMBDA_CURRENT_RESERVED_CONCURRENCY_TYPE,aws.LAMBDA_CURRENT_RESERVED_CONCURRENCY_VALUE,aws.LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_TYPE,aws.LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_VALUE" --format json 2>&1 || echo "{}")

if [ "$nrn_output" != "{}" ]; then
  LAMBDA_FUNCTION_ARN=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_FUNCTION_ARN // ""')
  LAMBDA_ROLE_ARN=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_ROLE_ARN // ""')
  LAMBDA_CURRENT_VERSION=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_FUNCTION_CURRENT_VERSION // ""')
  stored_alias=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_FUNCTION_MAIN_ALIAS // ""')
  if [ -n "$stored_alias" ] && [ "$stored_alias" != "null" ]; then
    LAMBDA_MAIN_ALIAS_NAME="$stored_alias"
  fi

  # Read current concurrency state for rollback tracking
  LAMBDA_CURRENT_RESERVED_CONCURRENCY_TYPE=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_CURRENT_RESERVED_CONCURRENCY_TYPE // ""')
  LAMBDA_CURRENT_RESERVED_CONCURRENCY_VALUE=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_CURRENT_RESERVED_CONCURRENCY_VALUE // ""')
  LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_TYPE=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_TYPE // ""')
  LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_VALUE=$(echo "$nrn_output" | jq -r '.namespaces.aws.LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_VALUE // ""')
else
  LAMBDA_CURRENT_RESERVED_CONCURRENCY_TYPE=""
  LAMBDA_CURRENT_RESERVED_CONCURRENCY_VALUE=""
  LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_TYPE=""
  LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_VALUE=""
fi

if [ -n "$LAMBDA_FUNCTION_ARN" ] && [ "$LAMBDA_FUNCTION_ARN" != "null" ]; then
  echo "   ‚úÖ Found existing Lambda: $LAMBDA_FUNCTION_ARN"
else
  echo "   ‚úÖ No existing Lambda found (initial deployment)"
fi

# Get visibility to determine networking layer
VISIBILITY=$(echo "$CONTEXT" | jq -r '.scope.visibility // "public"')
echo "   ‚úÖ visibility=$VISIBILITY"

echo "   ‚úÖ strategy=$DEPLOYMENT_STRATEGY"
echo "   ‚úÖ desired_traffic=$DESIRED_TRAFFIC"

# Check if this is blue-green deployment
IS_BLUE_GREEN="false"
BLUE_DEPLOYMENT_ID=""
if [ "$DEPLOYMENT_STRATEGY" = "blue_green" ] || [ "$DEPLOYMENT_STRATEGY" = "BLUE_GREEN" ]; then
  IS_BLUE_GREEN="true"
  BLUE_DEPLOYMENT_ID=$(echo "$CONTEXT" | jq -r '.scope.current_active_deployment // ""')
  echo "   ‚úÖ blue_deployment_id=$BLUE_DEPLOYMENT_ID"
fi

# Extract provider credentials
echo ""
echo "   üîë Extracting provider credentials..."

AWS_REGION=$(get_config_value \
  --provider '.providers["cloud-providers"].credentials.region' \
  --env AWS_REGION \
  --default "us-east-1"
)
echo "   ‚úÖ aws_region=$AWS_REGION"
echo "   ‚úÖ aws_credentials=service_account"

# Extract assets-repository credentials for S3 access
ASSETS_ACCESS_KEY_ID=$(echo "$CONTEXT" | jq -r '.providers["assets-repository"].credentials.access_key_id // ""')
ASSETS_SECRET_ACCESS_KEY=$(echo "$CONTEXT" | jq -r '.providers["assets-repository"].credentials.secret_access_key // ""')
ASSETS_REGION=$(echo "$CONTEXT" | jq -r '.providers["assets-repository"].credentials.region // ""')

if [ -n "$ASSETS_ACCESS_KEY_ID" ] && [ "$ASSETS_ACCESS_KEY_ID" != "null" ]; then
  echo "   ‚úÖ assets_credentials=configured"
else
  echo "   ‚úÖ assets_credentials=using cloud-provider credentials"
fi

# Extract Lambda configuration from capabilities
echo ""
echo "   ‚öôÔ∏è Extracting Lambda configuration..."

LAMBDA_RUNTIME=$(get_config_value \
  --provider '.scope.capabilities.runtime' \
  --env DEFAULT_RUNTIME \
  --default "nodejs20.x"
)
echo "   ‚úÖ runtime=$LAMBDA_RUNTIME"

LAMBDA_HANDLER=$(get_config_value \
  --provider '.scope.capabilities.handler' \
  --env DEFAULT_HANDLER \
  --default "index.handler"
)
echo "   ‚úÖ handler=$LAMBDA_HANDLER"

LAMBDA_MEMORY=$(get_config_value \
  --provider '.scope.capabilities.memory' \
  --env DEFAULT_MEMORY \
  --default "256"
)
echo "   ‚úÖ memory=$LAMBDA_MEMORY"

LAMBDA_TIMEOUT=$(get_config_value \
  --provider '.scope.capabilities.timeout' \
  --env DEFAULT_TIMEOUT \
  --default "30"
)
echo "   ‚úÖ timeout=$LAMBDA_TIMEOUT"

LAMBDA_ARCHITECTURE=$(get_config_value \
  --provider '.scope.capabilities.architecture' \
  --env DEFAULT_ARCHITECTURE \
  --default "arm64"
)
echo "   ‚úÖ architecture=$LAMBDA_ARCHITECTURE"

LAMBDA_EPHEMERAL_STORAGE=$(get_config_value \
  --provider '.scope.capabilities.ephemeral_storage' \
  --env DEFAULT_EPHEMERAL_STORAGE \
  --default "512"
)
echo "   ‚úÖ ephemeral_storage=$LAMBDA_EPHEMERAL_STORAGE"

LAMBDA_LAYERS=$(echo "$CONTEXT" | jq -c '.scope.capabilities.layers // []')
echo "   ‚úÖ layers=$LAMBDA_LAYERS"

# Extract concurrency settings from capabilities
echo ""
echo "   üîÑ Extracting concurrency settings..."

RESERVED_CONCURRENCY_TYPE=$(get_config_value \
  --provider '.scope.capabilities.reserved_concurrency.type' \
  --env DEFAULT_RESERVED_CONCURRENCY_TYPE \
  --default "unreserved"
)
echo "   ‚úÖ reserved_concurrency_type=$RESERVED_CONCURRENCY_TYPE"

RESERVED_CONCURRENCY_VALUE=$(echo "$CONTEXT" | jq -r '.scope.capabilities.reserved_concurrency.value // 0')
echo "   ‚úÖ reserved_concurrency_value=$RESERVED_CONCURRENCY_VALUE"

PROVISIONED_CONCURRENCY_TYPE=$(get_config_value \
  --provider '.scope.capabilities.provisioned_concurrency.type' \
  --env DEFAULT_PROVISIONED_CONCURRENCY_TYPE \
  --default "unprovisioned"
)
echo "   ‚úÖ provisioned_concurrency_type=$PROVISIONED_CONCURRENCY_TYPE"

PROVISIONED_CONCURRENCY_VALUE=$(echo "$CONTEXT" | jq -r '.scope.capabilities.provisioned_concurrency.value // 0')
echo "   ‚úÖ provisioned_concurrency_value=$PROVISIONED_CONCURRENCY_VALUE"

WARMUP_ALIAS_NAME=$(get_config_value \
  --provider '.scope.capabilities.provisioned_concurrency.warmup_alias' \
  --env LAMBDA_WARMUP_ALIAS_NAME \
  --default ""
)
echo "   ‚úÖ warmup_alias_name=$WARMUP_ALIAS_NAME"

# Extract VPC configuration
echo ""
echo "   üåê Extracting VPC configuration..."

VPC_ENABLED=$(echo "$CONTEXT" | jq -r '.scope.capabilities.vpc_enabled // false')
echo "   ‚úÖ vpc_enabled=$VPC_ENABLED"

SUBNET_IDS=$(echo "$CONTEXT" | jq -c '.providers["cloud-providers"].networking.subnet_ids // []')
echo "   ‚úÖ subnet_ids=$SUBNET_IDS"

SECURITY_GROUP_IDS=$(echo "$CONTEXT" | jq -c '.providers["cloud-providers"].networking.security_group_ids // []')
echo "   ‚úÖ security_group_ids=$SECURITY_GROUP_IDS"

# Extract asset info (S3 zip or ECR container image)
echo ""
echo "   üì¶ Extracting asset information..."

ASSET_URL=$(echo "$CONTEXT" | jq -r '.asset.url // ""')
ASSET_TYPE=$(echo "$CONTEXT" | jq -r '.asset.type // "lambda-asset"')
PACKAGE_TYPE="Zip"
IMAGE_URI=""
S3_BUCKET=""
S3_KEY=""

echo "   ‚úÖ asset_type=$ASSET_TYPE"

if [ "$ASSET_TYPE" = "docker-image" ]; then
  # Container image deployment (ECR)
  PACKAGE_TYPE="Image"

  if [ -n "$ASSET_URL" ] && [ "$ASSET_URL" != "null" ]; then
    IMAGE_URI="$ASSET_URL"
    echo "   ‚úÖ package_type=$PACKAGE_TYPE"
    echo "   ‚úÖ image_uri=$IMAGE_URI"
  else
    echo "‚ùå Asset URL is required for docker-image asset type" >&2
    echo "üí° Possible causes:" >&2
    echo "   - The build did not produce a container image URL" >&2
    echo "   - The asset object is missing the url field" >&2
    echo "üîß How to fix:" >&2
    echo "   - Verify the build pipeline pushes the image to ECR and sets asset.url" >&2
    echo "   - Expected format: {account}.dkr.ecr.{region}.amazonaws.com/{repo}:{tag}" >&2
    return 1
  fi
else
  # Zip deployment (S3)
  PACKAGE_TYPE="Zip"

  if [ -n "$ASSET_URL" ] && [ "$ASSET_URL" != "null" ]; then
    # Parse s3://bucket/key format
    if [[ "$ASSET_URL" =~ ^s3://([^/]+)/(.+)$ ]]; then
      S3_BUCKET="${BASH_REMATCH[1]}"
      S3_KEY="${BASH_REMATCH[2]}"
      echo "   ‚úÖ package_type=$PACKAGE_TYPE"
      echo "   ‚úÖ s3_bucket=$S3_BUCKET"
      echo "   ‚úÖ s3_key=$S3_KEY"
    else
      echo "‚ùå Invalid asset URL format: $ASSET_URL" >&2
      echo "üí° Possible causes:" >&2
      echo "   - Asset URL does not match expected s3://bucket/key format" >&2
      echo "üîß How to fix:" >&2
      echo "   - Verify the asset was uploaded correctly to S3" >&2
      echo "   - Expected format: s3://bucket-name/path/to/asset.zip" >&2
      return 1
    fi
  else
    echo "   ‚úÖ asset_url=not provided (may be set later)"
  fi
fi

# Parameters strategy
echo ""
echo "   üìù Extracting parameters..."

PARAMETERS_STRATEGY=$(get_config_value \
  --env PARAMETERS_STRATEGY \
  --default "env"
)
echo "   ‚úÖ parameters_strategy=$PARAMETERS_STRATEGY"

SECRETS_MANAGER_SECRET_ARN=""

if [ "$PARAMETERS_STRATEGY" = "secretsmanager" ]; then
  # Secrets Manager strategy: parameters go to SM, Lambda gets secret ARN
  SECRETS_MANAGER_SECRET_NAME="nullplatform/${SCOPE_ID}/parameters"
  AWS_ACCOUNT_ID=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].credentials.account_id // ""')

  if [ -n "$AWS_ACCOUNT_ID" ] && [ "$AWS_ACCOUNT_ID" != "null" ]; then
    SECRETS_MANAGER_SECRET_ARN="arn:aws:secretsmanager:${AWS_REGION}:${AWS_ACCOUNT_ID}:secret:${SECRETS_MANAGER_SECRET_NAME}"
  else
    # Build ARN using STS if account_id not in context
    SECRETS_MANAGER_SECRET_ARN=""
  fi

  echo "   ‚úÖ secrets_manager_secret_name=$SECRETS_MANAGER_SECRET_NAME"

  # Don't put parameters into env vars, just inject the secret name
  LAMBDA_ENVIRONMENT_VARIABLES=$(jq -n \
    --arg secret_name "$SECRETS_MANAGER_SECRET_NAME" \
    '{NULLPLATFORM_PARAMETERS_SECRET: $secret_name}')

  echo "   ‚úÖ environment_variables=NULLPLATFORM_PARAMETERS_SECRET injected"
else
  # Env vars strategy: parameters go directly as Lambda env vars
  LAMBDA_ENVIRONMENT_VARIABLES=$(echo "$CONTEXT" | jq -c '
    [.parameters.results // [] | .[] | {(.name): .value}] | add // {}
  ')
  echo "   ‚úÖ environment_variables_count=$(echo "$LAMBDA_ENVIRONMENT_VARIABLES" | jq 'length')"
fi

# Inject special environment variables
LAMBDA_ENVIRONMENT_VARIABLES=$(echo "$LAMBDA_ENVIRONMENT_VARIABLES" | jq \
  --arg np_deployment_id "$DEPLOYMENT_ID" \
  '. + {NP_DEPLOYMENT_ID: $np_deployment_id}')

# null agent configuration
echo ""
echo "   ü§ñ Configuring null agent..."

USE_NULL_AGENT=$(get_config_value \
  --env USE_NULL_AGENT \
  --default "true"
)
echo "   ‚úÖ use_null_agent=$USE_NULL_AGENT"

NULL_AGENT_LAYER_ARN=$(get_config_value \
  --env NULL_AGENT_LAYER_ARN \
  --default ""
)
echo "   ‚úÖ null_agent_layer_arn=$NULL_AGENT_LAYER_ARN"

if [ "$USE_NULL_AGENT" = "true" ]; then
  NP_APIKEY=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].credentials.np_apikey // ""')
  if [ -z "$NP_APIKEY" ] || [ "$NP_APIKEY" = "null" ]; then
    NP_APIKEY=$(get_config_value \
      --env NULLPLATFORM_APIKEY \
      --default ""
    )
  fi

  AWS_LAMBDA_EXEC_WRAPPER="/opt/nullplatform/launcher.sh"

  if [ -n "$NP_APIKEY" ] && [ "$NP_APIKEY" != "null" ]; then
    LAMBDA_ENVIRONMENT_VARIABLES=$(echo "$LAMBDA_ENVIRONMENT_VARIABLES" | jq \
      --arg apikey "$NP_APIKEY" \
      --arg wrapper "$AWS_LAMBDA_EXEC_WRAPPER" \
      '. + {NULLPLATFORM_APIKEY: $apikey, AWS_LAMBDA_EXEC_WRAPPER: $wrapper}')
    echo "   ‚úÖ null_agent=enabled (NULLPLATFORM_APIKEY and AWS_LAMBDA_EXEC_WRAPPER injected)"

    # Add null agent layer to layers if configured
    if [ -n "$NULL_AGENT_LAYER_ARN" ]; then
      LAMBDA_LAYERS=$(echo "$LAMBDA_LAYERS" | jq --arg arn "$NULL_AGENT_LAYER_ARN" '. + [$arn]')
      echo "   ‚úÖ null_agent_layer=added ($NULL_AGENT_LAYER_ARN)"
    fi
  else
    echo "   ‚úÖ null_agent=skipped (no API key available)"
  fi
else
  echo "   ‚úÖ null_agent=disabled"
fi

# Set output directory
OUTPUT_DIR="$SERVICE_PATH/output/$SCOPE_ID"
if [ -n "${NP_OUTPUT_DIR:-}" ]; then
  OUTPUT_DIR="$NP_OUTPUT_DIR/output/$SCOPE_ID"
fi
mkdir -p "$OUTPUT_DIR"

# Set Terraform working directory
TF_WORKING_DIR="$OUTPUT_DIR/terraform"
TOFU_MODULE_DIR="$TF_WORKING_DIR"
mkdir -p "$TF_WORKING_DIR"

# State key for Terraform remote state
STATE_KEY="lambda/${SCOPE_ID}/terraform.tfstate"

# Initialize TOFU_INIT_VARIABLES and MODULES_TO_USE
TOFU_INIT_VARIABLES=""
MODULES_TO_USE=""

# Add state key to init variables
TOFU_INIT_VARIABLES="$TOFU_INIT_VARIABLES -backend-config=key=$STATE_KEY"

# Resource tags
RESOURCE_TAGS_JSON=$(jq -n \
  --arg scope_id "$SCOPE_ID" \
  --arg deployment_id "$DEPLOYMENT_ID" \
  --arg namespace "$NAMESPACE_SLUG" \
  --arg application "$APPLICATION_SLUG" \
  --arg scope "$SCOPE_SLUG" \
  '{
    "nullplatform:scope-id": $scope_id,
    "nullplatform:deployment-id": $deployment_id,
    "nullplatform:namespace": $namespace,
    "nullplatform:application": $application,
    "nullplatform:scope": $scope
  }')

# Build comprehensive TOFU_VARIABLES JSON
echo ""
echo "   üèóÔ∏è Building Tofu variables..."

TOFU_VARIABLES=$(jq -n \
  --arg state_key "$STATE_KEY" \
  --arg function_name "$LAMBDA_FUNCTION_NAME" \
  --arg function_arn "$LAMBDA_FUNCTION_ARN" \
  --arg role_arn "$LAMBDA_ROLE_ARN" \
  --arg current_version "$LAMBDA_CURRENT_VERSION" \
  --arg main_alias_name "$LAMBDA_MAIN_ALIAS_NAME" \
  --arg runtime "$LAMBDA_RUNTIME" \
  --arg handler "$LAMBDA_HANDLER" \
  --arg memory "$LAMBDA_MEMORY" \
  --arg timeout "$LAMBDA_TIMEOUT" \
  --arg architecture "$LAMBDA_ARCHITECTURE" \
  --arg ephemeral_storage "$LAMBDA_EPHEMERAL_STORAGE" \
  --argjson layers "$LAMBDA_LAYERS" \
  --arg reserved_concurrency_type "$RESERVED_CONCURRENCY_TYPE" \
  --arg reserved_concurrency_value "$RESERVED_CONCURRENCY_VALUE" \
  --arg provisioned_concurrency_type "$PROVISIONED_CONCURRENCY_TYPE" \
  --arg provisioned_concurrency_value "$PROVISIONED_CONCURRENCY_VALUE" \
  --arg warmup_alias_name "$WARMUP_ALIAS_NAME" \
  --arg current_reserved_concurrency_type "$LAMBDA_CURRENT_RESERVED_CONCURRENCY_TYPE" \
  --arg current_reserved_concurrency_value "$LAMBDA_CURRENT_RESERVED_CONCURRENCY_VALUE" \
  --arg current_provisioned_concurrency_type "$LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_TYPE" \
  --arg current_provisioned_concurrency_value "$LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_VALUE" \
  --arg vpc_enabled "$VPC_ENABLED" \
  --argjson subnet_ids "$SUBNET_IDS" \
  --argjson security_group_ids "$SECURITY_GROUP_IDS" \
  --arg package_type "$PACKAGE_TYPE" \
  --arg image_uri "$IMAGE_URI" \
  --arg s3_bucket "$S3_BUCKET" \
  --arg s3_key "$S3_KEY" \
  --argjson environment_variables "$LAMBDA_ENVIRONMENT_VARIABLES" \
  --arg aws_region "$AWS_REGION" \
  --arg visibility "$VISIBILITY" \
  --arg deployment_strategy "$DEPLOYMENT_STRATEGY" \
  --arg desired_traffic "$DESIRED_TRAFFIC" \
  --arg is_blue_green "$IS_BLUE_GREEN" \
  --arg blue_deployment_id "$BLUE_DEPLOYMENT_ID" \
  --arg scope_id "$SCOPE_ID" \
  --arg deployment_id "$DEPLOYMENT_ID" \
  --arg namespace_slug "$NAMESPACE_SLUG" \
  --arg application_slug "$APPLICATION_SLUG" \
  --arg scope_slug "$SCOPE_SLUG" \
  --argjson tags "$RESOURCE_TAGS_JSON" \
  --arg parameters_strategy "$PARAMETERS_STRATEGY" \
  --arg secrets_manager_secret_arn "$SECRETS_MANAGER_SECRET_ARN" \
  --arg use_null_agent "$USE_NULL_AGENT" \
  --arg null_agent_layer_arn "$NULL_AGENT_LAYER_ARN" \
  '{
    state_key: $state_key,
    function_name: $function_name,
    function_arn: $function_arn,
    role_arn: $role_arn,
    current_version: $current_version,
    main_alias_name: $main_alias_name,
    runtime: $runtime,
    handler: $handler,
    memory: ($memory | tonumber),
    timeout: ($timeout | tonumber),
    architecture: $architecture,
    ephemeral_storage: ($ephemeral_storage | tonumber),
    layers: $layers,
    reserved_concurrency_type: $reserved_concurrency_type,
    reserved_concurrency_value: ($reserved_concurrency_value | tonumber),
    provisioned_concurrency_type: $provisioned_concurrency_type,
    provisioned_concurrency_value: ($provisioned_concurrency_value | tonumber),
    warmup_alias_name: $warmup_alias_name,
    current_reserved_concurrency_type: $current_reserved_concurrency_type,
    current_reserved_concurrency_value: $current_reserved_concurrency_value,
    current_provisioned_concurrency_type: $current_provisioned_concurrency_type,
    current_provisioned_concurrency_value: $current_provisioned_concurrency_value,
    vpc_enabled: ($vpc_enabled == "true"),
    subnet_ids: $subnet_ids,
    security_group_ids: $security_group_ids,
    package_type: $package_type,
    image_uri: $image_uri,
    s3_bucket: $s3_bucket,
    s3_key: $s3_key,
    environment_variables: $environment_variables,
    aws_region: $aws_region,
    visibility: $visibility,
    deployment_strategy: $deployment_strategy,
    desired_traffic: ($desired_traffic | tonumber),
    is_blue_green: ($is_blue_green == "true"),
    blue_deployment_id: $blue_deployment_id,
    scope_id: $scope_id,
    deployment_id: $deployment_id,
    namespace_slug: $namespace_slug,
    application_slug: $application_slug,
    scope_slug: $scope_slug,
    tags: $tags,
    parameters_strategy: $parameters_strategy,
    secrets_manager_secret_arn: $secrets_manager_secret_arn,
    use_null_agent: ($use_null_agent == "true"),
    null_agent_layer_arn: $null_agent_layer_arn
  }')

echo "   ‚úÖ tofu_variables=built ($(echo "$TOFU_VARIABLES" | jq 'keys | length') keys)"

# Add Lambda context to CONTEXT for layer setup scripts
CONTEXT=$(echo "$CONTEXT" | jq \
  --arg fn "$LAMBDA_FUNCTION_NAME" \
  --arg role "$LAMBDA_ROLE_ARN" \
  --arg version "$LAMBDA_CURRENT_VERSION" \
  --arg alias "$LAMBDA_MAIN_ALIAS_NAME" \
  '. + {lambda: {function_name: $fn, role_arn: $role, current_version: $version, main_alias: $alias}}')

# Export all variables
export SCOPE_ID
export DEPLOYMENT_ID
export SCOPE_NRN
export NAMESPACE_SLUG
export APPLICATION_SLUG
export SCOPE_SLUG
export ACCOUNT_SLUG
export LAMBDA_FUNCTION_NAME
export LAMBDA_FUNCTION_ARN
export LAMBDA_ROLE_ARN
export LAMBDA_CURRENT_VERSION
export LAMBDA_MAIN_ALIAS_NAME
export VISIBILITY
export DEPLOYMENT_STRATEGY
export DESIRED_TRAFFIC
export IS_BLUE_GREEN
export BLUE_DEPLOYMENT_ID
export AWS_REGION
export ASSETS_ACCESS_KEY_ID
export ASSETS_SECRET_ACCESS_KEY
export ASSETS_REGION
export LAMBDA_RUNTIME
export LAMBDA_HANDLER
export LAMBDA_MEMORY
export LAMBDA_TIMEOUT
export LAMBDA_ARCHITECTURE
export LAMBDA_EPHEMERAL_STORAGE
export LAMBDA_LAYERS
export RESERVED_CONCURRENCY_TYPE
export RESERVED_CONCURRENCY_VALUE
export PROVISIONED_CONCURRENCY_TYPE
export PROVISIONED_CONCURRENCY_VALUE
export WARMUP_ALIAS_NAME
export LAMBDA_CURRENT_RESERVED_CONCURRENCY_TYPE
export LAMBDA_CURRENT_RESERVED_CONCURRENCY_VALUE
export LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_TYPE
export LAMBDA_CURRENT_PROVISIONED_CONCURRENCY_VALUE
export VPC_ENABLED
export SUBNET_IDS
export SECURITY_GROUP_IDS
export ASSET_TYPE
export PACKAGE_TYPE
export IMAGE_URI
export S3_BUCKET
export S3_KEY
export LAMBDA_ENVIRONMENT_VARIABLES
export PARAMETERS_STRATEGY
export SECRETS_MANAGER_SECRET_ARN
export USE_NULL_AGENT
export NULL_AGENT_LAYER_ARN
export OUTPUT_DIR
export TF_WORKING_DIR
export TOFU_MODULE_DIR
export STATE_KEY
export TOFU_VARIABLES
export TOFU_INIT_VARIABLES
export MODULES_TO_USE
export CONTEXT
export RESOURCE_TAGS_JSON

echo ""
echo "‚ú® Deployment context built successfully"
