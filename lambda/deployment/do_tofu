#!/bin/bash
set -euo pipefail

TOFU_ACTION="${TOFU_ACTION:-apply}"

echo "ðŸ“ Running tofu $TOFU_ACTION for deployment: $DEPLOYMENT_ID"
echo "ðŸ“‹ Lambda function: $LAMBDA_FUNCTION_NAME"

echo "ðŸ“‹ Working directory: $TF_WORKING_DIR"

# Verify tofu is installed
if ! command -v tofu &> /dev/null; then
  echo ""
  echo "âŒ OpenTofu (tofu) is not installed or not found in PATH"
  echo ""
  echo "ðŸ’¡ Possible causes:"
  echo "   - The agent container image does not include the tofu binary"
  echo "   - PATH does not include the tofu installation directory"
  echo ""
  echo "ðŸ”§ How to fix:"
  echo "   - Add OpenTofu to the agent container image"
  echo "   - Installation guide: https://opentofu.org/docs/intro/install/"
  echo "   - Verify with: which tofu"
  echo ""
  return 1
fi

tofu_version=$(tofu version 2>&1 | head -1)
echo "   âœ… tofu=$tofu_version"

# Verify working directory has terraform files
if [ ! -d "$TF_WORKING_DIR" ]; then
  echo "âŒ Working directory does not exist: $TF_WORKING_DIR"
  return 1
fi

tf_file_count=$(ls "$TF_WORKING_DIR"/*.tf 2>/dev/null | wc -l | tr -d ' ')
if [ "$tf_file_count" -eq 0 ]; then
  echo "âŒ No .tf files found in $TF_WORKING_DIR"
  echo "   Did you run compose_modules first?"
  return 1
fi

echo "ðŸ“‹ Found $tf_file_count .tf files"

# Generate tfvars from TOFU_VARIABLES
TOFU_VAR_FILE="$OUTPUT_DIR/tofu.tfvars.json"
echo "$TOFU_VARIABLES" > "$TOFU_VAR_FILE"

# Copy scripts if they exist
if [ -d "$SERVICE_PATH/deployment/scripts" ]; then
  cp -r "$SERVICE_PATH/deployment/scripts" "$TF_WORKING_DIR/" 2>/dev/null || true
fi

# Initialize tofu
echo "ðŸ“ Initializing tofu..."
tofu -chdir="$TF_WORKING_DIR" init -input=false $TOFU_INIT_VARIABLES

# Import placeholder resources that exist in AWS but not in Tofu state
# Scope creation creates a placeholder Lambda function + alias via AWS CLI outside of Tofu state.
# On initial deployment, we need to import them to avoid 409 ResourceConflictException.
if [ "$TOFU_ACTION" = "apply" ]; then
  echo ""
  echo "ðŸ“ Checking for resources to import..."

  main_alias_name=$(echo "$TOFU_VARIABLES" | jq -r '.lambda_main_alias_name // "main"')

  # Import Lambda function
  if ! tofu -chdir="$TF_WORKING_DIR" state show aws_lambda_function.main &>/dev/null; then
    if aws lambda get-function --function-name "$LAMBDA_FUNCTION_NAME" &>/dev/null 2>&1; then
      echo "   ðŸ“¡ Importing existing Lambda function: $LAMBDA_FUNCTION_NAME"
      tofu -chdir="$TF_WORKING_DIR" import -var-file="$TOFU_VAR_FILE" aws_lambda_function.main "$LAMBDA_FUNCTION_NAME"
      echo "   âœ… Lambda function imported"
    fi
  fi

  # Import main alias
  if ! tofu -chdir="$TF_WORKING_DIR" state show aws_lambda_alias.main &>/dev/null; then
    if aws lambda get-alias --function-name "$LAMBDA_FUNCTION_NAME" --name "$main_alias_name" &>/dev/null 2>&1; then
      echo "   ðŸ“¡ Importing existing Lambda alias: $LAMBDA_FUNCTION_NAME/$main_alias_name"
      tofu -chdir="$TF_WORKING_DIR" import -var-file="$TOFU_VAR_FILE" aws_lambda_alias.main "$LAMBDA_FUNCTION_NAME/$main_alias_name"
      echo "   âœ… Lambda alias imported"
    fi
  fi

  # Import CloudWatch log group (auto-created on first Lambda invocation)
  log_group_name="/aws/lambda/$LAMBDA_FUNCTION_NAME"
  if ! tofu -chdir="$TF_WORKING_DIR" state show aws_cloudwatch_log_group.lambda &>/dev/null; then
    if aws logs describe-log-groups --log-group-name-prefix "$log_group_name" \
        --query "logGroups[?logGroupName=='$log_group_name'] | [0].logGroupName" \
        --output text 2>/dev/null | grep -q "$log_group_name"; then
      echo "   ðŸ“¡ Importing existing CloudWatch log group: $log_group_name"
      tofu -chdir="$TF_WORKING_DIR" import -var-file="$TOFU_VAR_FILE" aws_cloudwatch_log_group.lambda "$log_group_name"
      echo "   âœ… CloudWatch log group imported"
    fi
  fi
fi

# Run tofu action
echo "ðŸ“ Running tofu $TOFU_ACTION..."
tofu_exit_code=0
tofu -chdir="$TF_WORKING_DIR" "$TOFU_ACTION" -auto-approve -var-file="$TOFU_VAR_FILE" || tofu_exit_code=$?
if [ $tofu_exit_code -ne 0 ]; then
  echo ""
  echo "âŒ Tofu $TOFU_ACTION failed with exit code $tofu_exit_code"
  echo ""
  return 1
fi

echo "âœ… Tofu $TOFU_ACTION completed successfully"

# Extract outputs if apply
if [ "$TOFU_ACTION" = "apply" ]; then
  echo ""
  echo "ðŸ“‹ Extracting terraform outputs..."

  # Get outputs as JSON
  outputs=$(tofu -chdir="$TF_WORKING_DIR" output -json 2>/dev/null || echo "{}")

  # Extract key values for export
  if [ "$outputs" != "{}" ]; then
    LAMBDA_FUNCTION_ARN=$(echo "$outputs" | jq -r '.lambda_function_arn.value // empty')
    LAMBDA_CURRENT_VERSION=$(echo "$outputs" | jq -r '.lambda_current_version.value // empty')
    API_GATEWAY_ID=$(echo "$outputs" | jq -r '.api_gateway_id.value // empty')
    API_GATEWAY_ENDPOINT=$(echo "$outputs" | jq -r '.api_gateway_endpoint.value // empty')

    if [ -n "$LAMBDA_FUNCTION_ARN" ]; then
      echo "   âœ… function_arn=$LAMBDA_FUNCTION_ARN"
      export LAMBDA_FUNCTION_ARN
    fi

    if [ -n "$LAMBDA_CURRENT_VERSION" ]; then
      echo "   âœ… version=$LAMBDA_CURRENT_VERSION"
      export LAMBDA_CURRENT_VERSION
    fi

    if [ -n "$API_GATEWAY_ID" ]; then
      echo "   âœ… api_gateway_id=$API_GATEWAY_ID"
      export API_GATEWAY_ID
    fi

    if [ -n "$API_GATEWAY_ENDPOINT" ]; then
      echo "   âœ… api_gateway_endpoint=$API_GATEWAY_ENDPOINT"
      export API_GATEWAY_ENDPOINT
    fi

    ALB_RULE_ARN=$(echo "$outputs" | jq -r '.alb_listener_rule_arn.value // empty')
    if [ -n "$ALB_RULE_ARN" ]; then
      echo "   âœ… alb_listener_rule_arn=$ALB_RULE_ARN"
      export ALB_RULE_ARN
    fi
  fi
fi
