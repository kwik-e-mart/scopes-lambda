#!/bin/bash
set -euo pipefail

source "$SERVICE_PATH/utils/log"

TOFU_ACTION="${TOFU_ACTION:-apply}"

log info "ðŸ“ Running tofu $TOFU_ACTION for deployment: $DEPLOYMENT_ID"
log debug "ðŸ“‹ Lambda function: $LAMBDA_FUNCTION_NAME"
log debug "ðŸ“‹ Working directory: $TF_WORKING_DIR"

# Verify tofu is installed
if ! command -v tofu &> /dev/null; then
  echo ""
  echo "âŒ OpenTofu (tofu) is not installed or not found in PATH" >&2
  echo "" >&2
  echo "ðŸ’¡ Possible causes:" >&2
  echo "   - The agent container image does not include the tofu binary" >&2
  echo "   - PATH does not include the tofu installation directory" >&2
  echo "" >&2
  echo "ðŸ”§ How to fix:" >&2
  echo "   - Add OpenTofu to the agent container image" >&2
  echo "   - Installation guide: https://opentofu.org/docs/intro/install/" >&2
  echo "   - Verify with: which tofu" >&2
  echo "" >&2
  return 1
fi

tofu_version=$(tofu version 2>&1 | head -1)
log debug "   âœ… tofu=$tofu_version"

# Verify working directory has terraform files
if [ ! -d "$TF_WORKING_DIR" ]; then
  echo "âŒ Working directory does not exist: $TF_WORKING_DIR" >&2
  return 1
fi

tf_file_count=$(ls "$TF_WORKING_DIR"/*.tf 2>/dev/null | wc -l | tr -d ' ')
if [ "$tf_file_count" -eq 0 ]; then
  echo "âŒ No .tf files found in $TF_WORKING_DIR" >&2
  echo "   Did you run compose_modules first?" >&2
  return 1
fi

log debug "ðŸ“‹ Found $tf_file_count .tf files"

# Generate tfvars from TOFU_VARIABLES
TOFU_VAR_FILE="$OUTPUT_DIR/tofu.tfvars.json"
echo "$TOFU_VARIABLES" > "$TOFU_VAR_FILE"

# Copy scripts if they exist
if [ -d "$SERVICE_PATH/deployment/scripts" ]; then
  cp -r "$SERVICE_PATH/deployment/scripts" "$TF_WORKING_DIR/" 2>/dev/null || true
fi

# Initialize tofu
log info "ðŸ“ Initializing tofu..."
tofu -chdir="$TF_WORKING_DIR" init -input=false $TOFU_INIT_VARIABLES

# Import placeholder resources that exist in AWS but not in Tofu state
# Scope creation creates a placeholder Lambda function + alias via AWS CLI outside of Tofu state.
# On initial deployment, we need to import them to avoid 409 ResourceConflictException.
if [ "$TOFU_ACTION" = "apply" ]; then
  echo ""
  log info "ðŸ“ Checking for resources to import..."

  main_alias_name=$(echo "$TOFU_VARIABLES" | jq -r '.lambda_main_alias_name // "main"')

  # Import Lambda function
  if ! tofu -chdir="$TF_WORKING_DIR" state show aws_lambda_function.main &>/dev/null; then
    if aws lambda get-function --function-name "$LAMBDA_FUNCTION_NAME" &>/dev/null 2>&1; then
      log info "   ðŸ“¡ Importing existing Lambda function: $LAMBDA_FUNCTION_NAME"
      tofu -chdir="$TF_WORKING_DIR" import -var-file="$TOFU_VAR_FILE" aws_lambda_function.main "$LAMBDA_FUNCTION_NAME"
      log debug "   âœ… Lambda function imported"
    fi
  fi

  # Import main alias
  if ! tofu -chdir="$TF_WORKING_DIR" state show aws_lambda_alias.main &>/dev/null; then
    if aws lambda get-alias --function-name "$LAMBDA_FUNCTION_NAME" --name "$main_alias_name" &>/dev/null 2>&1; then
      log info "   ðŸ“¡ Importing existing Lambda alias: $LAMBDA_FUNCTION_NAME/$main_alias_name"
      tofu -chdir="$TF_WORKING_DIR" import -var-file="$TOFU_VAR_FILE" aws_lambda_alias.main "$LAMBDA_FUNCTION_NAME/$main_alias_name"
      log debug "   âœ… Lambda alias imported"
    fi
  fi

  # Import CloudWatch log group (auto-created on first Lambda invocation)
  log_group_name="/aws/lambda/$LAMBDA_FUNCTION_NAME"
  if ! tofu -chdir="$TF_WORKING_DIR" state show aws_cloudwatch_log_group.lambda &>/dev/null; then
    if aws logs describe-log-groups --log-group-name-prefix "$log_group_name" \
        --query "logGroups[?logGroupName=='$log_group_name'] | [0].logGroupName" \
        --output text 2>/dev/null | grep -q "$log_group_name"; then
      log info "   ðŸ“¡ Importing existing CloudWatch log group: $log_group_name"
      tofu -chdir="$TF_WORKING_DIR" import -var-file="$TOFU_VAR_FILE" aws_cloudwatch_log_group.lambda "$log_group_name"
      log debug "   âœ… CloudWatch log group imported"
    fi
  fi
fi

# Run tofu action
log info "ðŸ“ Running tofu $TOFU_ACTION..."
tofu_exit_code=0
tofu -chdir="$TF_WORKING_DIR" "$TOFU_ACTION" -auto-approve -var-file="$TOFU_VAR_FILE" || tofu_exit_code=$?
if [ $tofu_exit_code -ne 0 ]; then
  echo ""
  echo "âŒ Tofu $TOFU_ACTION failed with exit code $tofu_exit_code" >&2
  echo "" >&2
  return 1
fi

log info "âœ… Tofu $TOFU_ACTION completed successfully"

# Extract outputs if apply
if [ "$TOFU_ACTION" = "apply" ]; then
  echo ""
  log info "ðŸ“‹ Extracting terraform outputs..."

  # Get outputs as JSON
  outputs=$(tofu -chdir="$TF_WORKING_DIR" output -json 2>/dev/null || echo "{}")

  # Extract key values for export
  if [ "$outputs" != "{}" ]; then
    LAMBDA_FUNCTION_ARN=$(echo "$outputs" | jq -r '.lambda_function_arn.value // empty')
    LAMBDA_CURRENT_VERSION=$(echo "$outputs" | jq -r '.lambda_current_version.value // empty')
    API_GATEWAY_ID=$(echo "$outputs" | jq -r '.api_gateway_id.value // empty')
    API_GATEWAY_ENDPOINT=$(echo "$outputs" | jq -r '.api_gateway_endpoint.value // empty')

    if [ -n "$LAMBDA_FUNCTION_ARN" ]; then
      log debug "   âœ… function_arn=$LAMBDA_FUNCTION_ARN"
      export LAMBDA_FUNCTION_ARN
    fi

    if [ -n "$LAMBDA_CURRENT_VERSION" ]; then
      log debug "   âœ… version=$LAMBDA_CURRENT_VERSION"
      export LAMBDA_CURRENT_VERSION
    fi

    if [ -n "$API_GATEWAY_ID" ]; then
      log debug "   âœ… api_gateway_id=$API_GATEWAY_ID"
      export API_GATEWAY_ID
    fi

    if [ -n "$API_GATEWAY_ENDPOINT" ]; then
      log debug "   âœ… api_gateway_endpoint=$API_GATEWAY_ENDPOINT"
      export API_GATEWAY_ENDPOINT
    fi

    ALB_RULE_ARN=$(echo "$outputs" | jq -r '.alb_listener_rule_arn.value // empty')
    if [ -n "$ALB_RULE_ARN" ]; then
      log debug "   âœ… alb_listener_rule_arn=$ALB_RULE_ARN"
      export ALB_RULE_ARN
    fi
  fi

  # If the alias was created by scope provisioning pointing to $LATEST (placeholder),
  # Tofu imports it but ignores function_version due to lifecycle.ignore_changes.
  # Explicitly update the alias to the published version so blue-green traffic
  # switching works correctly on the first deployment.
  if [ -n "$LAMBDA_CURRENT_VERSION" ] && [ "$LAMBDA_CURRENT_VERSION" != "" ]; then
    current_alias_version=$(aws lambda get-alias \
      --function-name "$LAMBDA_FUNCTION_NAME" \
      --name "$main_alias_name" \
      --query 'FunctionVersion' \
      --output text 2>/dev/null || echo "")

    if [ "$current_alias_version" = '$LATEST' ]; then
      echo ""
      log info "   ðŸ“¡ Alias points to \$LATEST - updating to published version $LAMBDA_CURRENT_VERSION..."
      aws lambda update-alias \
        --function-name "$LAMBDA_FUNCTION_NAME" \
        --name "$main_alias_name" \
        --function-version "$LAMBDA_CURRENT_VERSION" \
        --routing-config '{}' >/dev/null 2>&1 || true
      log debug "   âœ… Alias updated from \$LATEST to version $LAMBDA_CURRENT_VERSION"
    fi
  fi
fi
