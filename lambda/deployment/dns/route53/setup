#!/bin/bash

source "$SERVICE_PATH/utils/log"

log info "ðŸ” Validating Route53 DNS configuration..."

# Get hosted zone ID from context
# For private/internal scopes, prefer hosted_zone_id if available; fall back to public zone.
visibility=$(echo "$CONTEXT" | jq -r '.scope.capabilities.visibility // "public"')

if [ "$visibility" = "private" ] || [ "$visibility" = "internal" ]; then
  hosted_zone_id=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].networking.hosted_zone_id // empty')
  if [ -n "$hosted_zone_id" ] && [ "$hosted_zone_id" != "null" ]; then
    log debug "   âœ… Using private hosted zone (visibility=$visibility)"
  else
    # Fall back to public zone if no private zone is configured
    hosted_zone_id=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].networking.hosted_public_zone_id // empty')
    log warn "   âš ï¸  No hosted_zone_id configured, falling back to public zone"
  fi
else
  hosted_zone_id=$(echo "$CONTEXT" | jq -r '.providers["cloud-providers"].networking.hosted_public_zone_id // empty')
fi

if [ -z "$hosted_zone_id" ] || [ "$hosted_zone_id" = "null" ]; then
  echo ""
  echo "   âŒ No hosted zone ID configured" >&2
  echo "" >&2
  echo "  ðŸ”§ How to fix:" >&2
  echo "    1. Ensure there is an AWS cloud-provider configured at the correct NRN hierarchy level" >&2
  echo "    2. Set 'hosted_public_zone_id' (public scopes) or 'hosted_zone_id' (private/internal scopes)" >&2
  echo "" >&2
  return 1
fi
log debug "   âœ… hosted_zone_id=$hosted_zone_id"

# Extract scope information
scope_id=$(echo "$CONTEXT" | jq -r '.scope.id')
scope_slug=$(echo "$CONTEXT" | jq -r '.scope.slug')
application_slug=$(echo "$CONTEXT" | jq -r '.application.slug')
namespace_slug=$(echo "$CONTEXT" | jq -r '.namespace.slug')
account_slug=$(echo "$CONTEXT" | jq -r '.account.slug')

echo ""
log info "   ðŸ“¡ Fetching domain from Route 53 hosted zone..."

aws_output=$(aws route53 get-hosted-zone --id "$hosted_zone_id" 2>&1)
aws_exit_code=$?

if [ $aws_exit_code -ne 0 ]; then
  echo ""
  echo "   âŒ Failed to fetch Route 53 hosted zone information" >&2
  echo "" >&2

  if echo "$aws_output" | grep -q "NoSuchHostedZone"; then
    echo "  ðŸ”Ž Error: Hosted zone '$hosted_zone_id' does not exist" >&2
    echo "" >&2
    echo "  ðŸ’¡ Possible causes:" >&2
    echo "    â€¢ The hosted zone ID is incorrect or has a typo" >&2
    echo "    â€¢ The hosted zone was deleted" >&2
    echo "" >&2
    echo "  ðŸ”§ How to fix:" >&2
    echo "    1. Verify the hosted zone exists: aws route53 list-hosted-zones" >&2
    echo "    2. Update 'hosted_public_zone_id' in the AWS cloud-provider configuration" >&2

  elif echo "$aws_output" | grep -q "AccessDenied\|not authorized"; then
    echo "  ðŸ”’ Error: Permission denied when accessing Route 53" >&2
    echo "" >&2
    echo "  ðŸ’¡ Possible causes:" >&2
    echo "    â€¢ The AWS credentials don't have Route 53 read permissions" >&2
    echo "" >&2
    echo "  ðŸ”§ How to fix:" >&2
    echo "    1. Ensure the IAM policy includes route53:GetHostedZone permission" >&2

  else
    echo "  ðŸ“‹ Error details:" >&2
    echo "$aws_output" | sed 's/^/    /' >&2
  fi

  echo "" >&2
  return 1
fi

network_domain=$(echo "$aws_output" | jq -r '.HostedZone.Name' | sed 's/\.$//')

if [ -z "$network_domain" ] || [ "$network_domain" = "null" ]; then
  echo ""
  echo "   âŒ Failed to extract domain name from hosted zone response" >&2
  echo "" >&2
  return 1
fi

log debug "   âœ… domain=$network_domain"

# Generate subdomain based on pattern
use_account_slug="${USE_ACCOUNT_SLUG:-true}"

if [ "$use_account_slug" = "true" ]; then
  network_subdomain="${namespace_slug}-${application_slug}-${scope_slug}.${account_slug}"
else
  network_subdomain="${namespace_slug}-${application_slug}-${scope_slug}"
fi

log debug "   âœ… subdomain=$network_subdomain"

# Full domain
scope_domain="${network_subdomain}.${network_domain}"
log debug "   âœ… full_domain=$scope_domain"

# Determine the DNS target based on visibility
visibility=$(echo "$CONTEXT" | jq -r '.scope.capabilities.visibility // "public"')

# These will be set by the networking layer via terraform locals
# For API Gateway: api_gateway_target_domain, api_gateway_target_zone_id
# For ALB: the ALB domain from the listener

TOFU_VARIABLES=$(echo "$TOFU_VARIABLES" | jq \
  --arg hosted_zone_id "$hosted_zone_id" \
  --arg domain "$network_domain" \
  --arg subdomain "$network_subdomain" \
  --arg full_domain "$scope_domain" \
  '. + {
    dns_hosted_zone_id: $hosted_zone_id,
    dns_domain: $domain,
    dns_subdomain: $subdomain,
    dns_full_domain: $full_domain
  }')

# Configure API Gateway custom domain if API Gateway is being used
api_gateway_name=$(echo "$TOFU_VARIABLES" | jq -r '.api_gateway_name // empty')
if [ -n "$api_gateway_name" ]; then
  cert_arn="${CERTIFICATE_ARN:-}"

  if [ -n "$cert_arn" ]; then
    log debug "   âœ… certificate_arn=$cert_arn"
    log info "   ðŸ“ Configuring API Gateway custom domain: $scope_domain"

    TOFU_VARIABLES=$(echo "$TOFU_VARIABLES" | jq \
      --arg domain "$scope_domain" \
      --arg cert "$cert_arn" \
      '. + {
        api_gateway_custom_domain: $domain,
        api_gateway_certificate_arn: $cert,
        dns_use_api_gateway: true,
        dns_use_api_gateway_cname: false
      }')
  else
    log warn "   âš ï¸  CERTIFICATE_ARN not set - using CNAME to execute-api endpoint (no custom SSL)"
    TOFU_VARIABLES=$(echo "$TOFU_VARIABLES" | jq '. + {dns_use_api_gateway_cname: true}')
  fi
fi

echo ""
log info "   ðŸ“ Setting scope domain to '$scope_domain'..."

np_output=$(np scope patch --id "$scope_id" --body "{\"domain\":\"$scope_domain\"}" --format json 2>&1)
np_exit_code=$?

if [ $np_exit_code -ne 0 ]; then
  echo ""
  echo "   âŒ Failed to update scope domain" >&2
  echo "" >&2

  if echo "$np_output" | grep -q "unauthorized\|forbidden\|401\|403"; then
    echo "  ðŸ”’ Error: Permission denied" >&2
    echo "" >&2
    echo "  ðŸ’¡ Possible causes:" >&2
    echo "    â€¢ The nullplatform API Key doesn't have 'Developer' permissions" >&2
    echo "" >&2
  else
    echo "  ðŸ“‹ Error details:" >&2
    echo "$np_output" | sed 's/^/    /' >&2
  fi

  echo "" >&2
  return 1
fi

log debug "   âœ… Scope domain set successfully"

echo ""
log info "âœ¨ Route53 DNS configured successfully"
echo ""

# Add module to composition list
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
module_name="${script_dir}/modules"

if [[ -n $MODULES_TO_USE ]]; then
  MODULES_TO_USE="$MODULES_TO_USE,$module_name"
else
  MODULES_TO_USE="$module_name"
fi
